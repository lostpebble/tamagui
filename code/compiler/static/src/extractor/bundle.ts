import { join } from 'node:path'
import esbuild from 'esbuild'
import * as FS from 'fs-extra'
import type { TamaguiPlatform } from '../types'
import { esbuildAliasPlugin } from './esbuildAliasPlugin'
import { resolveWebOrNativeSpecificEntry } from './loadTamagui'
import { TsconfigPathsPlugin } from './esbuildTsconfigPaths'

export const esbuildLoaderConfig = {
  '.js': 'jsx',
  '.png': 'dataurl',
  '.jpg': 'dataurl',
  '.jpeg': 'dataurl',
  '.svg': 'dataurl',
  '.gif': 'dataurl',
  '.webp': 'dataurl',
  '.woff2': 'dataurl',
  '.woff': 'dataurl',
  '.eot': 'dataurl',
  '.otf': 'dataurl',
  '.ttf': 'dataurl',
  '.mp4': 'file',
  '.mpeg4': 'file',
  '.mov': 'file',
  '.avif': 'file',
  '.wmv': 'file',
  '.webm': 'file',
  '.wav': 'file',
  '.aac': 'file',
  '.ogg': 'file',
  '.flac': 'file',
  '.node': 'empty',
} as const

const dataExtensions = Object.keys(esbuildLoaderConfig)
  .filter(
    (k) => esbuildLoaderConfig[k] === 'file' || esbuildLoaderConfig[k] === 'dataurl'
  )
  .map((k) => k.slice(1))

export const esbuildIgnoreFilesRegex = new RegExp(`.(${dataExtensions.join('|')})$`, 'i')

/**
 * For internal loading of new files
 */

type Props = Omit<Partial<esbuild.BuildOptions>, 'entryPoints'> & {
  outfile: string
  entryPoints: string[]
  resolvePlatformSpecificEntries?: boolean
}

function getESBuildConfig(
  { entryPoints, resolvePlatformSpecificEntries, ...options }: Props,
  platform: TamaguiPlatform,
  aliases?: Record<string, string>
) {
  if (process.env.DEBUG?.startsWith('tamagui')) {
    console.info(`Building`, entryPoints)
  }

  const resolvedEntryPoints = !resolvePlatformSpecificEntries
    ? entryPoints
    : entryPoints.map(resolveWebOrNativeSpecificEntry)

  const res: esbuild.BuildOptions = {
    bundle: true,
    entryPoints: resolvedEntryPoints,
    format: 'cjs',
    target: 'node20',
    jsx: 'transform',
    jsxFactory: 'react',
    allowOverwrite: true,
    keepNames: true,
    resolveExtensions: [
      ...(process.env.TAMAGUI_TARGET === 'web'
        ? ['.web.tsx', '.web.ts', '.web.jsx', '.web.js']
        : ['.native.tsx', '.native.ts', '.native.jsx', '.native.js']),
      '.tsx',
      '.ts',
      '.jsx',
      '.js',
    ],
    platform: 'node',
    tsconfigRaw: {
      compilerOptions: {
        jsx: 'react-jsx',
      },
    },
    loader: esbuildLoaderConfig,
    logLevel: 'warning',
    plugins: [
      TsconfigPathsPlugin(),

      {
        name: 'external',
        setup(build) {
          // externalize @tamagui packages to avoid bundling CJS shim files
          // that esbuild can't convert (they use Object.assign + require pattern)
          // but don't externalize entry points (esbuild doesn't allow that)
          build.onResolve({ filter: /^@tamagui\// }, (args) => {
            // entry points cannot be external
            if (args.kind === 'entry-point') {
              return null
            }
            // special case: @tamagui/core and @tamagui/web resolve to /native for native platform
            if (args.path.match(/^@tamagui\/(core|web)$/)) {
              return {
                path: platform === 'native' ? '@tamagui/core/native' : args.path,
                external: true,
              }
            }
            return {
              path: args.path,
              external: true,
            }
          })

          build.onResolve({ filter: /react-native\/package.json$/ }, (args) => {
            return {
              path: 'react-native/package.json',
              external: true,
            }
          })

          build.onResolve({ filter: /^(react-native|react-native\/.*)$/ }, (args) => {
            return {
              path: '@tamagui/react-native-web-lite',
              external: true,
            }
          })

          build.onResolve({ filter: /react-native-reanimated/ }, (args) => {
            return {
              path: 'react-native-reanimated',
              external: true,
            }
          })

          // externalize animation libraries - not needed for static extraction
          build.onResolve({ filter: /^(framer-motion|motion)/ }, (args) => {
            return {
              path: args.path,
              external: true,
            }
          })
        },
      },
      esbuildAliasPlugin({
        ...aliases,
      }),
    ],
    ...options,
  }

  return res
}

export async function esbundleTamaguiConfig(
  props: Props,
  platform: TamaguiPlatform,
  aliases?: Record<string, string>
) {
  const config = getESBuildConfig(props, platform, aliases)

  // build to memory first, then write atomically (temp file + rename)
  // to prevent other threads from reading partially-written files
  const tmpFile = props.outfile + '.tmp.' + process.pid
  const result = await esbuild.build({
    ...config,
    outfile: tmpFile,
  })

  // atomic rename prevents other threads from reading partial files
  await FS.rename(tmpFile, props.outfile)

  return result
}
